from collections import deque as Queue def breadth_first_search(startnode, goalnode): queue = Queue() queue.append(startnode) nodesseen = set() nodesseen.add(startnode) #buggy line: while True: node = queue.popleft() if node is goalnode: return True else: queue.extend(node for node in node.successors if node not in nodesseen) nodesseen.update(node.successors) return Falsefrom collections import deque as Queue def breadth_first_search(startnode, goalnode): queue = Queue() queue.append(startnode) nodesseen = set() nodesseen.add(startnode) #buggy line: while True: if queue.popleft() in nodesseen: node = queue.popleft() if node is goalnode: return True else: queue.extend(node for node in node.successors if node not in nodesseen) nodesseen.update(node.successors) return Falsefrom collections import deque as Queue def breadth_first_search(startnode, goalnode): queue = Queue() queue.append(startnode) nodesseen = set() nodesseen.add(startnode) #buggy line: while True: if queue.popleft() in nodesseen: nodesseen.add(startnode) node = queue.popleft() if node is goalnode: return True else: queue.extend(node for node in node.successors if node not in nodesseen) nodesseen.update(node.successors) return Falsefrom collections import deque as Queue def breadth_first_search(startnode, goalnode): queue = Queue() queue.append(startnode) nodesseen = set() nodesseen.add(startnode) #buggy line: while True: node = queue.popleft() if node is startnode: return True else: queue.extend(node for node in node.successors if node not in nodesseen) nodesseen.update(node.successors) return Falsefrom collections import deque as Queue def breadth_first_search(startnode, goalnode): queue = Queue() queue.append(startnode) nodesseen = set() nodesseen.add(startnode) #buggy line: while True: node = queue.popleft() if node is startnode: return True else: queue.extend(node for node in node.successors if node is goalnode: return True else: queue.extend(node for node in node.successors if node not in nodesseen) nodesseen.update(node.successors) return Falsefrom collections import deque as Queue def breadth_first_search(startnode, goalnode): queue = Queue() queue.append(startnode) nodesseen = set() nodesseen.add(startnode) #buggy line: while True: node = queue.popleft() if node is startnode: return True else: queue.extend(node for node in node.successors if node is goalnode): return True else: queue.extend(node for node in node.successors if node not in nodesseen) nodesseen.update(node.successors) return Falsefrom collections import deque as Queue def breadth_first_search(startnode, goalnode): queue = Queue() queue.append(startnode) nodesseen = set() nodesseen.add(startnode) #buggy line: while True: node = queue.popleft() if node is startnode: return True else: queue.extend(node for node in node.successors if node in nodesseen) nodesseen.update(node.successors) return Falsefrom collections import deque as Queue def breadth_first_search(startnode, goalnode): queue = Queue() queue.append(startnode) nodesseen = set() nodesseen.add(startnode) #buggy line: while True: node = queue.popleft() if node is startnode: nodesseen.update(node.successors) queue.extend(node for node in node.successors if node not in nodesseen) nodesseen.update(node.successors) return False queue.extend(startnode for node in node.successors if node not in nodesseen) nodesseen.update(node.successors) return Falsefrom collections import deque as Queue def breadth_first_search(startnode, goalnode): queue = Queue() queue.append(startnode) nodesseen = set() nodesseen.add(startnode) #buggy line: while True: node = queue.popleft() if node is startnode: nodesseen.update(node.successors) queue.extend(node for node in node.successors if node not in nodesseen) nodesseen.update(node.successors) return Falsefrom collections import deque as Queue def breadth_first_search(startnode, goalnode): queue = Queue() queue.append(startnode) nodesseen = set() nodesseen.add(startnode) #buggy line: while True: node = queue.popleft() if node is startnode: nodesseen.update(node.successors) queue.extend(node for node in node.successors if node not in nodesseen) nodesseen.update(node.successors) return False queue.extend(startnode for node in node.successors if node is goalnode): nodesseen.update(node.successors) return False