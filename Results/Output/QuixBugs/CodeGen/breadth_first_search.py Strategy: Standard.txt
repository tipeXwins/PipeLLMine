
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while len(queue) > 0:
        currentnode = queue.popleft()

        if currentnode == goalnode:
            return True

        for neighbor in currentnode.neighbors:
            if neighbor not in nodesseen:
                queue.append(neighbor)
                nodesseen.add(neighbor)

    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(startnode
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while len(queue) > 0:
        currentnode = queue.popleft()
        if currentnode == goalnode:
            return True
        for neighbor in currentnode.neighbors:
            if neighbor not in nodesseen:
                queue.append(neighbor)
                nodesseen.add(neighbor)
    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(startnode
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while len(queue) > 0:
        currentnode = queue.popleft()

        if currentnode == goalnode:
            return True

        for neighbor in currentnode.neighbors:
            if neighbor not in nodesseen:
                nodesseen.add(neighbor)
                queue.append(neighbor)

    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(startnode
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while len(queue) > 0:
        currentnode = queue.popleft()

        if currentnode == goalnode:
            return True

        for nextnode in currentnode.neighbours:
            if nextnode not in nodesseen:
                queue.append(nextnode)
                nodesseen.add(nextnode)

    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(start
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while len(queue) > 0:
        currentnode = queue.popleft()
        if currentnode == goalnode:
            return True
        for nextnode in currentnode.neighbours:
            if nextnode not in nodesseen:
                queue.append(nextnode)
                nodesseen.add(nextnode)
    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(start
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while len(queue) > 0:
        currentnode = queue.popleft()

        if currentnode == goalnode:
            return True

        for nextnode in currentnode.get_neighbours():
            if nextnode not in nodesseen:
                queue.append(nextnode)
                nodesseen.add(nextnode)

    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while len(queue) > 0:
        currentnode = queue.popleft()

        if currentnode == goalnode:
            return True

        for nextnode in currentnode.get_neighbours():
            if nextnode not in nodesseen:
                queue.append(nextnode)
                nodesseen.add(nextnode)

    return False


def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while len(queue) > 0:
        currentnode = queue.popleft()

        if currentnode == goalnode:
            return True

        for neighbor in currentnode.neighbors:
            if neighbor not in nodesseen:
                queue.append(neighbor)
                nodesseen.add(neighbor)

    return False

class Node:
    def __init__(self, name):
        self.name = name
        self.neighbors = set()

    def add_neighbor(self, neighbor):
        
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while len(queue) > 0:
        currentnode = queue.popleft()

        if currentnode == goalnode:
            return True

        for nextnode in currentnode.get_neighbours():
            if nextnode not in nodesseen:
                queue.append(nextnode)
                nodesseen.add(nextnode)

    return False

from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while len(queue) > 0:
        currentnode = queue.popleft()

        if currentnode == goalnode:
            return True

        for neighbor in currentnode.neighbors:
            if neighbor not in nodesseen:
                queue.append(neighbor)
                nodesseen.add(neighbor)

    return False

class Node:
    def __init__(self, name):
        self.name = name
        self.neighbors = []

    def add_neighbor(self, neighbor):
        self