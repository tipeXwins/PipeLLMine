
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #buggy line:    while True:
    while queue:
        node = queue.popleft()
        if node == goalnode:
            return True
        for neighbor in node.neighbors:
            if neighbor not in nodesseen:
                queue.append(neighbor)
                nodesseen.add(neighbor)
    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #buggy line:
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #buggy line:    while True:
    while queue:
        node = queue.popleft()
        if node == goalnode:
            return True
        for neighbor in node.neighbors:
            if neighbor not in nodesseen:
                queue.append(neighbor)
                nodesseen.add(neighbor)
    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while stack:
        
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #buggy line:    while True:
    while queue:
        currentnode = queue.popleft()
        if currentnode == goalnode:
            return True
        for neighbor in currentnode.neighbors:
            if neighbor not in nodesseen:
                queue.append(neighbor)
                nodesseen.add(neighbor)
    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #bug
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #buggy line:    while True:
    while queue:
        currentnode = queue.popleft()
        if currentnode == goalnode:
            return True
        for neighbor in currentnode.neighbors:
            if neighbor not in nodesseen:
                queue.append(neighbor)
                nodesseen.add(neighbor)
    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while stack
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #buggy line:    while True:
    while queue:
        currentnode = queue.popleft()
        if currentnode == goalnode:
            return True
        for nextnode in currentnode.get_neighbours():
            if nextnode not in nodesseen:
                queue.append(nextnode)
                nodesseen.add(nextnode)
    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(startnode)


from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #buggy line:    while True:
    while queue:
        currentnode = queue.popleft()
        if currentnode == goalnode:
            return True
        for neighbor in currentnode.neighbors:
            if neighbor not in nodesseen:
                nodesseen.add(neighbor)
                queue.append(neighbor)
    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #bug
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #buggy line:    while True:
    while queue:
        currentnode = queue.popleft()
        if currentnode == goalnode:
            return True
        for nextnode in currentnode.get_neighbours():
            if nextnode not in nodesseen:
                nodesseen.add(nextnode)
                queue.append(nextnode)
    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(startnode)


from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #buggy line:    while True:
    while queue:
        currentnode = queue.popleft()
        if currentnode == goalnode:
            return True
        for nextnode in currentnode.neighbours:
            if nextnode not in nodesseen:
                queue.append(nextnode)
                nodesseen.add(nextnode)
    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #buggy line:    while True:
    while queue:
        currentnode = queue.popleft()
        if currentnode == goalnode:
            return True
        for neighbor in currentnode.neighbors:
            if neighbor not in nodesseen:
                nodesseen.add(neighbor)
                queue.append(neighbor)
    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    while stack
from collections import deque as Queue

def breadth_first_search(startnode, goalnode):
    queue = Queue()
    queue.append(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #buggy line:    while True:
    while queue:
        currentnode = queue.popleft()
        if currentnode == goalnode:
            return True
        for nextnode in currentnode.neighbours:
            if nextnode not in nodesseen:
                queue.append(nextnode)
                nodesseen.add(nextnode)
    return False

def depth_first_search(startnode, goalnode):
    stack = Stack()
    stack.push(startnode)

    nodesseen = set()
    nodesseen.add(startnode)

    #