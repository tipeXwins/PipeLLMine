--- pennylane/pennylane#481/after/_qubit_device.py	2022-01-10 16:02:54.000000000 +0000
+++ pennylane/pennylane#481/before/_qubit_device.py	2022-01-10 16:02:54.000000000 +0000
@@ -19,7 +19,6 @@
 # e.g. instead of expval(self, observable, wires, par) have expval(self, observable)
 # pylint: disable=arguments-differ, abstract-method, no-value-for-parameter,too-many-instance-attributes
 import abc
-import itertools
 
 import numpy as np
 
@@ -72,6 +71,8 @@
         values, variances, and probabilities. If ``False``, samples are used
         to estimate the statistical quantities above."""
 
+        self._wires_measured = set()
+        """set[int]: wires acted on by quantum operations and observables"""
         self._samples = None
         """None or array[int]: stores the samples generated by the device
         *after* rotation to diagonalize the observables."""
@@ -100,6 +101,7 @@
         After the reset, the backend should be as if it was just constructed.
         Most importantly the quantum state is reset to its initial value.
         """
+        self._wires_measured = set()
         self._samples = None
 
     def execute(self, circuit):
@@ -129,6 +131,8 @@
         # apply all circuit operations
         self.apply(circuit.operations, circuit.diagonalizing_gates)
 
+        # determine the wires that are measured by the circuit
+        self._wires_measured = QubitDevice.active_wires(circuit.observables)
         # generate computational basis samples
         if (not self.analytic) or circuit.is_sampled:
             self.generate_samples()
@@ -190,7 +194,11 @@
         """
         wires = []
         for op in operators:
-            wires.extend(op.wires)
+            for wire in op.wires:
+                if isinstance(wire, int):
+                    wires.append(wire)
+                else:
+                    wires.extend(wire)
 
         return set(wires)
 
@@ -244,10 +252,10 @@
             This method should be overwritten on devices that
             generate their own computational basis samples.
         """
-        number_of_states = 2 ** self.num_wires
-        rotated_prob = self.probability()
+        number_of_states = 2 ** len(self._wires_measured)
+        rotated_prob = self.probability(self._wires_measured)
         samples = self.sample_basis_states(number_of_states, rotated_prob)
-        self._samples = QubitDevice.states_to_binary(samples, self.num_wires)
+        self._samples = QubitDevice.states_to_binary(samples, number_of_states)
 
     def sample_basis_states(self, number_of_states, state_probability):
         """Sample from the computational basis states based on the state
