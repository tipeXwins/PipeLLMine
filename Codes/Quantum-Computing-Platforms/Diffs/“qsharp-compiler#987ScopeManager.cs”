28,29c28
<             private readonly Action<Func<ITypeRef, string?>, (IValue, bool)[]> increaseCounts;
<             private readonly Action<Func<ITypeRef, string?>, (IValue, bool)[]> decreaseCounts;
---
>             private readonly ScopeManager parent;
53c52
<             private readonly List<Action> requiredReleases = new List<Action>();
---
>             private readonly List<(IValue, string)> requiredReleases = new List<(IValue, string)>();
55c54
<             public Scope(Action<Func<ITypeRef, string?>, (IValue, bool)[]> increaseCounts, Action<Func<ITypeRef, string?>, (IValue, bool)[]> decreaseCounts)
---
>             public Scope(ScopeManager parent)
57,58c56
<                 this.increaseCounts = increaseCounts;
<                 this.decreaseCounts = decreaseCounts;
---
>                 this.parent = parent;
140,141c138
<                 var change = new[] { (value, true) }; // true refers to whether the change also applies to inner items
<                 this.increaseCounts(AliasCountUpdateFunctionForType, change);
---
>                 this.parent.ModifyCounts(this.parent.AliasCountUpdateFunctionForType, this.parent.plusOne, value, recurIntoInnerItems: true);
148c145
<                     this.increaseCounts(ReferenceCountUpdateFunctionForType, change);
---
>                     this.parent.ModifyCounts(this.parent.ReferenceCountUpdateFunctionForType, this.parent.plusOne, value, recurIntoInnerItems: true);
161c158
<                 if (RequiresReferenceCount(value.LlvmType))
---
>                 if (this.parent.RequiresReferenceCount(value.LlvmType))
171,175c168,169
<             public void RegisterRelease(IValue value, Action<IValue> releaseFunction)
<             {
<                 var loadedValue = LoadValue(value);
<                 this.requiredReleases.Add(() => releaseFunction(loadedValue));
<             }
---
>             public void RegisterRelease(IValue value, string releaseFunction) =>
>                 this.requiredReleases.Add((LoadValue(value), releaseFunction));
183c177
<                 if (RequiresReferenceCount(value.LlvmType))
---
>                 if (this.parent.RequiresReferenceCount(value.LlvmType))
202c196,201
<                 this.increaseCounts(ReferenceCountUpdateFunctionForType, pending);
---
>                 this.parent.ModifyCounts(this.parent.ReferenceCountUpdateFunctionForType, this.parent.plusOne, pending);
>             }
>             internal void MigratePendingReferences(Scope scope)
>             {
>                 scope.pendingReferences.AddRange(this.pendingReferences);
>                 this.pendingReferences.Clear();
221c220
<                 if (RequiresReferenceCount(value.LlvmType))
---
>                 if (this.parent.RequiresReferenceCount(value.LlvmType))
233a233,234
>             internal void ExecutePendingCalls(bool applyReferences = true) =>
>                 ExecutePendingCalls(this.parent, applyReferences, this);
235c236
<             internal void ExecutePendingCalls(params Scope[] parentScopes)
---
>             internal static void ExecutePendingCalls(ScopeManager parent, bool forceApplyReferences, params Scope[] scopes)
236a238,241
>                 if (!scopes.Any())
>                 {
>                     return;
>                 }
239,240c244,245
<                 var allScopes = parentScopes.Prepend(this);
<                 var pendingAliasCounts = allScopes.SelectMany(s => s.variables).Select(kv => (kv.Value, true)).ToArray();
---
>                 var pendingAliasCounts = scopes.SelectMany(s => s.variables).Select(kv => (kv.Value, true)).ToArray();
>                 var appliesUnreferences = pendingAliasCounts.Any(v => v.Value is PointerValue) || scopes.Any(s => s.requiredUnreferences.Any());
242,244c247,249
<                 var pendingReferences = this.ClearPendingReferences()
<                     .Concat(parentScopes.SelectMany(scope => scope.pendingReferences))
<                     .ToList();
---
>                 var pendingReferences = forceApplyReferences || appliesUnreferences
>                     ? scopes.First().ClearPendingReferences()
>                     : new List<(IValue, bool)>();
246c251
<                 var pendingUnreferences = allScopes
---
>                 var pendingUnreferences = scopes
249c254
<                     .SelectMany(v => Expand(ReferenceCountUpdateFunctionForType, v.Item1, v.Item2, pendingReferences))
---
>                     .SelectMany(v => Expand(parent.ReferenceCountUpdateFunctionForType, v.Item1, v.Item2, pendingReferences))
253c258
<                     .SelectMany(v => Expand(ReferenceCountUpdateFunctionForType, v.Item1, v.Item2))
---
>                     .SelectMany(v => Expand(parent.ReferenceCountUpdateFunctionForType, v.Item1, v.Item2))
266,268c271,273
<                 this.increaseCounts(ReferenceCountUpdateFunctionForType, pendingReferences.ToArray());
<                 this.decreaseCounts(AliasCountUpdateFunctionForType, pendingAliasCounts);
<                 this.decreaseCounts(ReferenceCountUpdateFunctionForType, pendingUnreferences.ToArray());
---
>                 parent.ModifyCounts(parent.ReferenceCountUpdateFunctionForType, parent.plusOne, pendingReferences.ToArray());
>                 parent.ModifyCounts(parent.AliasCountUpdateFunctionForType, parent.minusOne, pendingAliasCounts);
>                 parent.ModifyCounts(parent.ReferenceCountUpdateFunctionForType, parent.minusOne, pendingUnreferences.ToArray());
270c275
<                 foreach (var release in allScopes.SelectMany(s => s.requiredReleases))
---
>                 foreach (var (value, funcName) in scopes.SelectMany(s => s.requiredReleases))
272c277,278
<                     release();
---
>                     var func = parent.sharedState.GetOrCreateRuntimeFunction(funcName);
>                     parent.sharedState.CurrentBuilder.Call(func, value.Value);
311c317
<         private static string? AliasCountUpdateFunctionForType(ITypeRef t)
---
>         private string? AliasCountUpdateFunctionForType(ITypeRef t)
336c342
<         private static string? ReferenceCountUpdateFunctionForType(ITypeRef t)
---
>         private string? ReferenceCountUpdateFunctionForType(ITypeRef t)
447,455d452
<         private void ExecutePendingCalls(bool keepCurrentScope = false)
<         {
<             var current = keepCurrentScope ? this.scopes.Peek() : this.scopes.Pop();
<             if (current.HasPendingReferences && keepCurrentScope)
<             {
<                 throw new InvalidOperationException("scope contains pending calls to increase reference counts");
<             }
<             current.ExecutePendingCalls();
<         }
466,469c463,466
<         public void OpenScope() =>
<             this.scopes.Push(new Scope(
<                 increaseCounts: (fct, items) => this.ModifyCounts(fct, this.plusOne, items),
<                 decreaseCounts: (fct, items) => this.ModifyCounts(fct, this.minusOne, items)));
---
>         public void OpenScope()
>         {
>             this.scopes.Push(new Scope(this));
>         }
483a481
>             var scope = this.scopes.Peek();
486c484
<                 this.ExecutePendingCalls();
---
>                 scope.ExecutePendingCalls();
488c486
<             else
---
>             if (scope.HasPendingReferences)
490,494c488
<                 var scope = this.scopes.Pop();
<                 if (scope.HasPendingReferences)
<                 {
<                     throw new InvalidOperationException("cannot close scope that has pending calls to increase reference counts");
<                 }
---
>                 throw new InvalidOperationException("cannot close scope that has pending calls to increase reference counts");
495a490
>             _ = this.scopes.Pop();
501a497
>         /// Delays applying pending calls to increase reference counts if no values are unreferenced unless allowDelayReferencing is set to false.
508c504
<         public void CloseScope(IValue returned)
---
>         public void CloseScope(IValue returned, bool allowDelayReferencing = true)
509a506
>             var scope = this.scopes.Peek();
511c508,514
<             this.ExecutePendingCalls();
---
>             scope.ExecutePendingCalls(applyReferences: !allowDelayReferencing);
>             scope = this.scopes.Pop();
> 
>             if (allowDelayReferencing)
>             {
>                 scope.MigratePendingReferences(this.scopes.Peek());
>             }
512a516,517
>         internal void ApplyPendingReferences() =>
>             this.scopes.Peek().ApplyPendingReferences();
527,530c532,543
<         public void ExitScope() =>
<             this.ExecutePendingCalls(keepCurrentScope: true);
<         internal void ApplyPendingReferences() =>
<             this.scopes.Peek().ApplyPendingReferences();
---
>         public void ExitScope(bool isTerminated)
>         {
>             var scope = this.scopes.Peek();
>             if (scope.HasPendingReferences)
>             {
>                 throw new InvalidOperationException("cannot exit scope that has pending calls to increase reference counts");
>             }
>             if (!isTerminated)
>             {
>                 scope.ExecutePendingCalls();
>             }
>         }
533,534c546,547
<         internal static bool RequiresReferenceCount(ITypeRef type) =>
<             ReferenceCountUpdateFunctionForType(type) != null;
---
>         internal bool RequiresReferenceCount(ITypeRef type) =>
>             this.ReferenceCountUpdateFunctionForType(type) != null;
561c574
<             this.ModifyCounts(ReferenceCountUpdateFunctionForType, change, value, !shallow);
---
>             this.ModifyCounts(this.ReferenceCountUpdateFunctionForType, change, value, !shallow);
583,584c596,597
<             this.ModifyCounts(ReferenceCountUpdateFunctionForType, this.plusOne, value, !shallow);
<             this.ModifyCounts(AliasCountUpdateFunctionForType, this.plusOne, value, !shallow);
---
>             this.ModifyCounts(this.ReferenceCountUpdateFunctionForType, this.plusOne, value, !shallow);
>             this.ModifyCounts(this.AliasCountUpdateFunctionForType, this.plusOne, value, !shallow);
596c609
<             this.ModifyCounts(AliasCountUpdateFunctionForType, this.minusOne, value, !shallow);
---
>             this.ModifyCounts(this.AliasCountUpdateFunctionForType, this.minusOne, value, !shallow);
607c620
<             this.ModifyCounts(AliasCountUpdateFunctionForType, change, value, !shallow);
---
>             this.ModifyCounts(this.AliasCountUpdateFunctionForType, change, value, !shallow);
624c637
<             var releaseFunctionName =
---
>             var releaser =
628,629c641
<             var release = this.sharedState.GetOrCreateRuntimeFunction(releaseFunctionName);
<             this.scopes.Peek().RegisterRelease(value, loaded => this.sharedState.CurrentBuilder.Call(release, loaded.Value));
---
>             this.scopes.Peek().RegisterRelease(value, releaser);
703a716
>             var currentScopes = this.scopes.ToArray();
705c718
<             this.scopes.Peek().ExecutePendingCalls(this.scopes.Skip(1).ToArray());
---
>             Scope.ExecutePendingCalls(this, true, currentScopes);
