314a315,322
>   // Set distributed parallelization
>   void
>   set_distributed_parallelization(const std::vector<Circuit> &circuits,
>                                   const std::vector<Noise::NoiseModel> &noise);
> 
>   void set_distributed_parallelization_method(
>       const std::vector<Circuit> &circuits,
>       const std::vector<Noise::NoiseModel> &noise);
324a333,334
>   uint_t get_distributed_num_processes(bool par_shots) const;
> 
326c336
<     if (sim_device_ == Device::GPU && num_gpus_ > 0) {
---
>     if (num_gpus_ > 0) {
357a368,380
>   // distributed experiments (MPI)
>   int distributed_experiments_rank_ = 0;
>   int distributed_experiments_group_id_ = 0;
>   uint_t distributed_experiments_num_processes_ = 1;
>   int distributed_experiments_ = 1;
>   uint_t num_process_per_experiment_;
>   uint_t distributed_experiments_begin_;
>   uint_t distributed_experiments_end_;
> 
>   // distributed shots (MPI)
>   int distributed_shots_rank_ = 0;
>   int distributed_shots_ = 1;
> 
361d383
<   int num_process_per_experiment_ = 1;
530a553,554
>   distributed_experiments_ = 1;
>   distributed_shots_ = 1;
541,547c565
<     const std::vector<Noise::NoiseModel> &noise) 
< {
<   if(circuits.size() == 1){
<     parallel_experiments_ = 1;
<     return;
<   }
< 
---
>     const std::vector<Noise::NoiseModel> &noise) {
551c569
<       (max_parallel_experiments_ > 1)
---
>       (max_parallel_experiments_ > 0)
555c573
<   if (max_experiments == 1) {
---
>   if (max_experiments == 1 && num_processes_ == 1) {
561a580,590
> #ifdef AER_MPI
>   std::vector<size_t> required_memory_mb_list(distributed_experiments_end_ -
>                                               distributed_experiments_begin_);
>   for (size_t j = 0;
>        j < distributed_experiments_end_ - distributed_experiments_begin_; j++) {
>     required_memory_mb_list[j] =
>         required_memory_mb(circuits[j + distributed_experiments_begin_],
>                            noise[j + distributed_experiments_begin_]) /
>         num_process_per_experiment_;
>   }
> #else
565a595
> #endif
572c602
<     if (total_memory > max_memory_mb_)
---
>     if (total_memory > max_memory_mb_ * num_process_per_experiment_)
579a610,615
> #ifdef AER_MPI
>   parallel_experiments_ = std::min<int>(
>       {parallel_experiments_, max_experiments, max_parallel_threads_,
>        static_cast<int>(distributed_experiments_end_ -
>                         distributed_experiments_begin_)});
> #else
582a619
> #endif
586,587c623,624
<                                              const Noise::NoiseModel &noise) 
< {
---
>                                              const Noise::NoiseModel &noise) {
> 
605,606c642
<     size_t mem_size = (sim_device_ == Device::GPU) ? max_memory_mb_ + max_gpu_memory_mb_ : max_memory_mb_;
<     if (mem_size < circ_memory_mb)
---
>     if (max_memory_mb_ + max_gpu_memory_mb_ < circ_memory_mb)
611a648,652
> #ifdef AER_MPI
>     int shots =
>         (circ.shots * (distributed_shots_rank_ + 1) / distributed_shots_) -
>         (circ.shots * distributed_shots_rank_ / distributed_shots_);
> #else
612a654
> #endif
621a664,746
> void Controller::set_distributed_parallelization(
>     const std::vector<Circuit> &circuits,
>     const std::vector<Noise::NoiseModel> &noise) {
>   std::vector<size_t> required_memory_mb_list(circuits.size());
>   num_process_per_experiment_ = 1;
>   for (size_t j = 0; j < circuits.size(); j++) {
>     size_t size = required_memory_mb(circuits[j], noise[j]);
>     if (size > max_memory_mb_ + max_gpu_memory_mb_) {
>       num_process_per_experiment_ =
>           std::max<int>(num_process_per_experiment_,
>                         (size + (max_memory_mb_ + max_gpu_memory_mb_) - 1) /
>                             (max_memory_mb_ + max_gpu_memory_mb_));
>     }
>   }
>   while ((num_processes_ % num_process_per_experiment_) != 0) {
>     num_process_per_experiment_++;
>   }
> 
>   distributed_experiments_ = num_processes_ / num_process_per_experiment_;
> 
>   if (circuits.size() < distributed_experiments_) {
>     // e.g. np = 8, circuits = 3, npe = 2,  de = 4 -> 3 , then np_in_group =
>     // [3,3,2]
>     //      np = 4, circuits = 1, npe = 2,  de = 2 -> 1 , then np_in_group = [4]
>     distributed_experiments_ = circuits.size();
> 
>     distributed_experiments_num_processes_ =
>         (num_processes_ + distributed_experiments_ - 1) /
>         distributed_experiments_;
>     distributed_experiments_group_id_ =
>         myrank_ / distributed_experiments_num_processes_;
>     if ((distributed_experiments_group_id_ + 1) *
>             distributed_experiments_num_processes_ >
>         num_processes_) {
>       distributed_experiments_num_processes_ =
>           num_processes_ - distributed_experiments_group_id_ *
>                                distributed_experiments_num_processes_;
>     }
> 
>     if (distributed_experiments_num_processes_ > num_process_per_experiment_ &&
>         (distributed_experiments_num_processes_ %
>          num_process_per_experiment_) == 0) {
>       distributed_shots_ =
>           distributed_experiments_num_processes_ / num_process_per_experiment_;
>       distributed_shots_rank_ = 0;
>     } else {
>       // shots are not distributed
>       distributed_shots_ = 1;
>       distributed_shots_rank_ = 0;
>     }
>     distributed_experiments_rank_ = myrank_ % distributed_experiments_;
> 
>     distributed_experiments_begin_ = distributed_experiments_group_id_;
>     distributed_experiments_end_ = distributed_experiments_begin_ + 1;
>   } else {
>     distributed_experiments_group_id_ = myrank_ / num_process_per_experiment_;
>     distributed_experiments_rank_ = myrank_ % num_process_per_experiment_;
>     distributed_experiments_num_processes_ = num_process_per_experiment_;
> 
>     distributed_experiments_begin_ = circuits.size() *
>                                      distributed_experiments_group_id_ /
>                                      distributed_experiments_;
>     distributed_experiments_end_ = circuits.size() *
>                                    (distributed_experiments_group_id_ + 1) /
>                                    distributed_experiments_;
> 
>     // shots are not distributed
>     distributed_shots_ = 1;
>     distributed_shots_rank_ = 0;
>   }
> }
> 
> uint_t Controller::get_distributed_num_processes(bool par_shots) const {
>   if (par_shots) {
>     return num_process_per_experiment_;
>   } else {
>     return distributed_experiments_num_processes_; // no shot distribution,
>                                                    // parallelize this
>                                                    // experiment by processes in
>                                                    // group
>   }
> }
> 
623,624c748
<                                          const Noise::NoiseModel &noise) const 
< {
---
>                                          const Noise::NoiseModel &noise) const {
627c751,753
<   if (cache_block_qubit_ >= 2 && cache_block_qubit_ < circ.num_qubits)
---
> 
>   if (num_process_per_experiment_ > 1 ||
>       Controller::get_min_memory_mb() < required_memory_mb(circ, noise))
630,639c756,757
<   if(num_process_per_experiment_ == 1 && sim_device_ == Device::GPU && num_gpus_ > 0){
<     return (max_gpu_memory_mb_ / num_gpus_ < required_memory_mb(circ, noise));
<   }
<   if(num_process_per_experiment_ > 1){
<     size_t total_mem = max_memory_mb_;
<     if(sim_device_ == Device::GPU)
<       total_mem += max_gpu_memory_mb_;
<     if(total_mem*num_process_per_experiment_ > required_memory_mb(circ, noise))
<       return true;
<   }
---
>   if (cache_block_qubit_ >= 2 && cache_block_qubit_ < circ.num_qubits)
>     return true;
644,646c762,773
< size_t Controller::get_system_memory_mb() 
< {
<   size_t total_physical_memory = Utils::get_system_memory_mb();
---
> size_t Controller::get_system_memory_mb() {
>   size_t total_physical_memory = 0;
> #if defined(__linux__) || defined(__APPLE__)
>   auto pages = sysconf(_SC_PHYS_PAGES);
>   auto page_size = sysconf(_SC_PAGE_SIZE);
>   total_physical_memory = pages * page_size;
> #elif defined(_WIN64) || defined(_WIN32)
>   MEMORYSTATUSEX status;
>   status.dwLength = sizeof(status);
>   GlobalMemoryStatusEx(&status);
>   total_physical_memory = status.ullTotalPhys;
> #endif
655c782
<   return total_physical_memory;
---
>   return total_physical_memory >> 20;
733,735c860
<                                                 
<   size_t mem_size = (sim_device_ == Device::GPU) ? max_memory_mb_ + max_gpu_memory_mb_ : max_memory_mb_;
<   if (mem_size < required_mb) {
---
>   if (max_memory_mb_ + max_gpu_memory_mb_ < required_mb) {
774c899
<       if(sim_device_ == Device::GPU && num_gpus_ > 0)
---
>       if (num_gpus_ > 0)
861a987,1000
> #ifdef AER_MPI
>     try {
>       // catch exception raised by required_memory_mb because of invalid
>       // simulation method
>       set_distributed_parallelization_method(circuits, circ_noise_models);
>     } catch (std::exception &e) {
>       save_exception_to_results(result, e);
>     }
> 
>     const auto num_circuits =
>         distributed_experiments_end_ - distributed_experiments_begin_;
>     result.resize(num_circuits);
> #endif
> 
863a1003,1006
> #ifdef AER_MPI
>     for (size_t j = distributed_experiments_begin_;
>          j < distributed_experiments_end_; j++) {
> #else
864a1008
> #endif
869d1012
<     num_process_per_experiment_ = num_processes_;
894a1038,1044
> #ifdef AER_MPI
>     result.metadata.add(distributed_experiments_, "distributed_experiments");
>     result.metadata.add(distributed_experiments_group_id_,
>                         "distributed_experiments_group_id");
>     result.metadata.add(distributed_experiments_rank_,
>                         "distributed_experiments_rank_in_group");
> #endif
916a1067,1070
>     uint_t offset = 0;
> #ifdef AER_MPI
>     offset = distributed_experiments_begin_;
> #endif
924c1078
<         execute_circuit(circuits[j], circ_noise_models[j],
---
>         execute_circuit(circuits[j + offset], circ_noise_models[j + offset],
929c1083
<         execute_circuit(circuits[j], circ_noise_models[j],
---
>         execute_circuit(circuits[j + offset], circ_noise_models[j + offset],
995a1150,1157
> #ifdef AER_MPI
>     if (parallel_shots_ > 1 &&
>         distributed_shots_ > 1) { // if shots can be distributed
>       shots =
>           (circ.shots * (distributed_shots_rank_ + 1) / distributed_shots_) -
>           (circ.shots * distributed_shots_rank_ / distributed_shots_);
>     }
> #endif
1064a1227,1231
> #ifdef AER_MPI
>     if (parallel_shots_ > 1 && distributed_shots_ > 1) {
>       result.metadata.add(distributed_shots_, "distributed_shots");
>     }
> #endif
1653a1821,1869
> void Controller::set_distributed_parallelization_method(
>     const std::vector<Circuit> &circuits,
>     const std::vector<Noise::NoiseModel> &noise) {
> #ifdef AER_MPI
>   uint_t i, ncircuits;
>   bool sample_opt = true;
> 
>   ncircuits = circuits.size();
>   for (i = 0; i < ncircuits; i++) {
>     const auto method = simulation_method(circuits[i], noise[i], false);
>     switch (method) {
>     case Method::statevector:
>     case Method::stabilizer:
>     case Method::unitary:
>     case Method::matrix_product_state: {
>       if (circuits[i].shots > 1 &&
>           (noise[i].has_quantum_errors() ||
>            !check_measure_sampling_opt(circuits[i], method))) {
>         sample_opt = false;
>       }
>       break;
>     }
>     case Method::density_matrix:
>     case Method::superop: {
>       if (circuits[i].shots > 1 &&
>           !check_measure_sampling_opt(circuits[i], method)) {
>         sample_opt = false;
>       }
>       break;
>     }
>     default: {
>       sample_opt = false;
>     }
>     }
>     if (!sample_opt) {
>       break;
>     }
>   }
> 
>   if (sample_opt) {
>     set_distributed_parallelization(circuits, noise);
> 
>     // shots are not distributed
>     distributed_shots_ = 1;
>     distributed_shots_rank_ = 0;
>   }
> #endif
> }
> 
1674c1890
<   state.set_distribution(num_processes_);
---
>   state.set_distribution(get_distributed_num_processes(shots == circ.shots));
