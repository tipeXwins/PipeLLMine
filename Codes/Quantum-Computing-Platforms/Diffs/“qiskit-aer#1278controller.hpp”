215a216,220
>   // Set distributed parallelization
>   virtual void
>   set_distributed_parallelization(const std::vector<Circuit> &circuits,
>                                   const std::vector<Noise::NoiseModel> &noise);
> 
232a238,239
>   uint_t get_distributed_num_processes(bool par_shots) const;
> 
266a274,278
>   //distributed experiments (MPI)
>   int distributed_experiments_rank_ = 0;
>   int distributed_experiments_group_id_ = 0;
>   uint_t distributed_experiments_num_processes_ = 1;
>   int distributed_experiments_ = 1;
267a280,285
>   uint_t distributed_experiments_begin_;
>   uint_t distributed_experiments_end_;
> 
>   //distributed shots (MPI)
>   int distributed_shots_rank_ = 0;
>   int distributed_shots_ = 1;
384a403,404
>   distributed_experiments_ = 1;
>   distributed_shots_ = 1;
409a430,435
> #ifdef AER_MPI
>   std::vector<size_t> required_memory_mb_list(distributed_experiments_end_ - distributed_experiments_begin_);
>   for (size_t j = 0; j < distributed_experiments_end_-distributed_experiments_begin_; j++) {
>     required_memory_mb_list[j] = required_memory_mb(circuits[j+distributed_experiments_begin_], noise[j+distributed_experiments_begin_]) / num_process_per_experiment_;
>   }
> #else
413a440
> #endif
427a455,459
> #ifdef AER_MPI
>   parallel_experiments_ =
>       std::min<int>({parallel_experiments_, max_experiments,
>                      max_parallel_threads_, static_cast<int>(distributed_experiments_end_ - distributed_experiments_begin_)});
> #else
430a463
> #endif
457a491,493
> #ifdef AER_MPI
>     int shots = (circ.shots * (distributed_shots_rank_ + 1)/distributed_shots_) - (circ.shots * distributed_shots_rank_ /distributed_shots_);
> #else
458a495
> #endif
468a506,571
> void Controller::set_distributed_parallelization(const std::vector<Circuit> &circuits,
>                                   const std::vector<Noise::NoiseModel> &noise)
> {
>   std::vector<size_t> required_memory_mb_list(circuits.size());
>   num_process_per_experiment_ = 1;
>   for (size_t j = 0; j < circuits.size(); j++) {
>     size_t size = required_memory_mb(circuits[j], noise[j]);
>     if(size > max_memory_mb_ + max_gpu_memory_mb_){
>       num_process_per_experiment_ = std::max<int>(num_process_per_experiment_,(size + (max_memory_mb_+max_gpu_memory_mb_) - 1) / (max_memory_mb_+max_gpu_memory_mb_));
>     }
>   }
>   while((num_processes_ % num_process_per_experiment_) != 0){
>     num_process_per_experiment_++;
>   }
> 
>   distributed_experiments_ = num_processes_ / num_process_per_experiment_;
> 
>   if(circuits.size() < distributed_experiments_){
>     // e.g. np = 8, circuits = 3, npe = 2,  de = 4 -> 3 , then np_in_group = [3,3,2]
>     //      np = 4, circuits = 1, npe = 2,  de = 2 -> 1 , then np_in_group = [4]
>     distributed_experiments_ = circuits.size();
> 
>     distributed_experiments_num_processes_ = (num_processes_ + distributed_experiments_ - 1)/distributed_experiments_;
>     distributed_experiments_group_id_ = myrank_ / distributed_experiments_num_processes_;
>     if((distributed_experiments_group_id_+1)*distributed_experiments_num_processes_ > num_processes_){
>       distributed_experiments_num_processes_ = num_processes_ - distributed_experiments_group_id_*distributed_experiments_num_processes_;
>     }
> 
>     if(distributed_experiments_num_processes_ > num_process_per_experiment_ && (distributed_experiments_num_processes_ % num_process_per_experiment_) == 0){
>       distributed_shots_ = distributed_experiments_num_processes_ / num_process_per_experiment_;
>       distributed_shots_rank_ = 0;
>     }
>     else{
>       //shots are not distributed
>       distributed_shots_ = 1;
>       distributed_shots_rank_ = 0;
>     }
>     distributed_experiments_rank_ = myrank_ % distributed_experiments_;
> 
>     distributed_experiments_begin_ = distributed_experiments_group_id_;
>     distributed_experiments_end_ = distributed_experiments_begin_ + 1;
>   }
>   else{
>     distributed_experiments_group_id_ = myrank_ / num_process_per_experiment_;
>     distributed_experiments_rank_ = myrank_ % num_process_per_experiment_;
>     distributed_experiments_num_processes_ = num_process_per_experiment_;
> 
>     distributed_experiments_begin_ = circuits.size() * distributed_experiments_group_id_ / distributed_experiments_;
>     distributed_experiments_end_ = circuits.size() * (distributed_experiments_group_id_ + 1) / distributed_experiments_;
> 
>     //shots are not distributed
>     distributed_shots_ = 1;
>     distributed_shots_rank_ = 0;
>   }
> }
> 
> uint_t Controller::get_distributed_num_processes(bool par_shots) const
> {
>   if(par_shots){
>     return num_process_per_experiment_;
>   }
>   else{
>     return distributed_experiments_num_processes_;    //no shot distribution, parallelize this experiment by processes in group
>   }
> }
> 
701a805,816
> #ifdef AER_MPI
>     try{
>       //catch exception raised by required_memory_mb because of invalid simulation method
>       set_distributed_parallelization(circuits, circ_noise_models);
>     }
>     catch (std::exception &e) {
>       save_exception_to_results(result,e);
>     }
> 
>     const auto num_circuits = distributed_experiments_end_ - distributed_experiments_begin_;
>     result.resize(num_circuits);
> #endif
704a820,822
> #ifdef AER_MPI
>     for (size_t j = distributed_experiments_begin_; j < distributed_experiments_end_; j++) {
> #else
705a824
> #endif
711d829
<     num_process_per_experiment_ = num_processes_;
734a853,857
> #ifdef AER_MPI
>     result.metadata.add(distributed_experiments_,"distributed_experiments");
>     result.metadata.add(distributed_experiments_group_id_,"distributed_experiments_group_id");
>     result.metadata.add(distributed_experiments_rank_,"distributed_experiments_rank_in_group");
> #endif
755a879,882
>     uint_t offset = 0;
> #ifdef AER_MPI
>     offset = distributed_experiments_begin_;
> #endif
762c889
<         execute_circuit(circuits[j], circ_noise_models[j], config, result.results[j]);
---
>         execute_circuit(circuits[j + offset], circ_noise_models[j + offset], config, result.results[j]);
766c893
<         execute_circuit(circuits[j], circ_noise_models[j], config, result.results[j]);
---
>         execute_circuit(circuits[j + offset], circ_noise_models[j + offset], config, result.results[j]);
833a961,965
> #ifdef AER_MPI
>     if(parallel_shots_ > 1 && distributed_shots_ > 1){   //if shots can be distributed
>       shots = (circ.shots * (distributed_shots_rank_ + 1)/distributed_shots_) - (circ.shots * distributed_shots_rank_ /distributed_shots_);
>     }
> #endif
902a1035,1039
> #ifdef AER_MPI
>     if(parallel_shots_ > 1 && distributed_shots_ > 1){
>       result.metadata.add(distributed_shots_,"distributed_shots");
>     }
> #endif
