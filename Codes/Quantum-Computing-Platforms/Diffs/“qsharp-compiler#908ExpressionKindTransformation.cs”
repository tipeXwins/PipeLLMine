130,133d129
<         private static bool ExpressionIsSelfEvaluating(TypedExpression ex) =>
<             ex.Expression.IsIdentifier || ex.Expression.IsBoolLiteral || ex.Expression.IsDoubleLiteral
<                 || ex.Expression.IsIntLiteral || ex.Expression.IsPauliLiteral || ex.Expression.IsRangeLiteral
<                 || ex.Expression.IsResultLiteral || ex.Expression.IsUnitValue;
385,421d380
<         private Value ConditionalEvaluation(Value condition, TypedExpression? onCondTrue = null, TypedExpression? onCondFalse = null)
<         {
<             var contBlock = this.SharedState.AddBlockAfterCurrent("condContinue");
<             var falseBlock = onCondFalse != null
<                 ? this.SharedState.AddBlockAfterCurrent("condFalse")
<                 : contBlock;
<             var trueBlock = onCondTrue != null
<                 ? this.SharedState.AddBlockAfterCurrent("condTrue")
<                 : contBlock;
<             this.SharedState.CurrentBuilder.Branch(condition, trueBlock, falseBlock);
<             var entryBlock = this.SharedState.CurrentBlock!;
<             var (evaluatedOnTrue, afterTrue) = (condition, entryBlock);
<             if (onCondTrue != null)
<             {
<                 this.SharedState.ScopeMgr.OpenScope();
<                 this.SharedState.SetCurrentBlock(trueBlock);
<                 var onTrue = this.SharedState.EvaluateSubexpression(onCondTrue);
<                 this.SharedState.ScopeMgr.CloseScope(onTrue, false); // force that the ref count is increased within the branch
<                 this.SharedState.CurrentBuilder.Branch(contBlock);
<                 (evaluatedOnTrue, afterTrue) = (onTrue.Value, this.SharedState.CurrentBlock!);
<             }
<             var (evaluatedOnFalse, afterFalse) = (condition, entryBlock);
<             if (onCondFalse != null)
<             {
<                 this.SharedState.ScopeMgr.OpenScope();
<                 this.SharedState.SetCurrentBlock(falseBlock);
<                 var onFalse = this.SharedState.EvaluateSubexpression(onCondFalse);
<                 this.SharedState.ScopeMgr.CloseScope(onFalse, false); // force that the ref count is increased within the branch
<                 this.SharedState.CurrentBuilder.Branch(contBlock);
<                 (evaluatedOnFalse, afterFalse) = (onFalse.Value, this.SharedState.CurrentBlock!);
<             }
<             this.SharedState.SetCurrentBlock(contBlock);
<             var phi = this.SharedState.CurrentBuilder.PhiNode(this.SharedState.CurrentLlvmExpressionType());
<             phi.AddIncoming(evaluatedOnTrue, afterTrue);
<             phi.AddIncoming(evaluatedOnFalse, afterFalse);
<             return phi;
<         }
892a852,855
>             static bool ExpressionIsSelfEvaluating(TypedExpression ex) =>
>                 ex.Expression.IsIdentifier || ex.Expression.IsBoolLiteral || ex.Expression.IsDoubleLiteral
>                     || ex.Expression.IsIntLiteral || ex.Expression.IsPauliLiteral || ex.Expression.IsRangeLiteral
>                     || ex.Expression.IsResultLiteral || ex.Expression.IsUnitValue;
908,909c871,893
<                 var evaluated = this.ConditionalEvaluation(cond.Value, onCondTrue: ifTrueEx, onCondFalse: ifFalseEx);
<                 value = this.SharedState.Values.From(evaluated, exType);
---
>                 var contBlock = this.SharedState.AddBlockAfterCurrent("condContinue");
>                 var falseBlock = this.SharedState.AddBlockAfterCurrent("condFalse");
>                 var trueBlock = this.SharedState.AddBlockAfterCurrent("condTrue");
>                 this.SharedState.CurrentBuilder.Branch(cond.Value, trueBlock, falseBlock);
>                 this.SharedState.ScopeMgr.OpenScope();
>                 this.SharedState.SetCurrentBlock(trueBlock);
>                 this.Transformation.Expressions.OnTypedExpression(ifTrueEx);
>                 var ifTrue = this.SharedState.ValueStack.Pop();
>                 this.SharedState.ScopeMgr.CloseScope(ifTrue, false); // force that the ref count is increased within the branch
>                 BasicBlock afterTrue = this.SharedState.CurrentBlock!;
>                 this.SharedState.CurrentBuilder.Branch(contBlock);
>                 this.SharedState.ScopeMgr.OpenScope();
>                 this.SharedState.SetCurrentBlock(falseBlock);
>                 this.Transformation.Expressions.OnTypedExpression(ifFalseEx);
>                 var ifFalse = this.SharedState.ValueStack.Pop();
>                 this.SharedState.ScopeMgr.CloseScope(ifFalse, false); // force that the ref count is increased within the branch
>                 BasicBlock afterFalse = this.SharedState.CurrentBlock!;
>                 this.SharedState.CurrentBuilder.Branch(contBlock);
>                 this.SharedState.SetCurrentBlock(contBlock);
>                 var phi = this.SharedState.CurrentBuilder.PhiNode(this.SharedState.CurrentLlvmExpressionType());
>                 phi.AddIncoming(ifTrue.Value, afterTrue);
>                 phi.AddIncoming(ifFalse.Value, afterFalse);
>                 value = this.SharedState.Values.From(phi, exType);
1332c1316,1317
<             Value evaluated;
---
>             var lhs = this.SharedState.EvaluateSubexpression(lhsEx);
>             var rhs = this.SharedState.EvaluateSubexpression(rhsEx);
1334,1345c1319,1320
<             if (ExpressionIsSelfEvaluating(rhsEx))
<             {
<                 var lhs = this.SharedState.EvaluateSubexpression(lhsEx);
<                 var rhs = this.SharedState.EvaluateSubexpression(rhsEx);
<                 evaluated = this.SharedState.CurrentBuilder.And(lhs.Value, rhs.Value);
<             }
<             else
<             {
<                 var cond = this.SharedState.EvaluateSubexpression(lhsEx).Value;
<                 evaluated = this.ConditionalEvaluation(cond, onCondTrue: rhsEx);
<             }
<             var value = this.SharedState.Values.FromSimpleValue(evaluated, exType);
---
>             var res = this.SharedState.CurrentBuilder.And(lhs.Value, rhs.Value);
>             var value = this.SharedState.Values.FromSimpleValue(res, exType);
1363c1338,1339
<             Value evaluated;
---
>             var lhs = this.SharedState.EvaluateSubexpression(lhsEx);
>             var rhs = this.SharedState.EvaluateSubexpression(rhsEx);
1365,1376c1341,1342
<             if (ExpressionIsSelfEvaluating(rhsEx))
<             {
<                 var lhs = this.SharedState.EvaluateSubexpression(lhsEx);
<                 var rhs = this.SharedState.EvaluateSubexpression(rhsEx);
<                 evaluated = this.SharedState.CurrentBuilder.Or(lhs.Value, rhs.Value);
<             }
<             else
<             {
<                 var cond = this.SharedState.EvaluateSubexpression(lhsEx).Value;
<                 evaluated = this.ConditionalEvaluation(cond, onCondFalse: rhsEx);
<             }
<             var value = this.SharedState.Values.FromSimpleValue(evaluated, exType);
---
>             var res = this.SharedState.CurrentBuilder.Or(lhs.Value, rhs.Value);
>             var value = this.SharedState.Values.FromSimpleValue(res, exType);
